#!/usr/bin/python3
###############################################################################
#                                                                             #
# libloc - A library to determine the location of someone on the Internet     #
#                                                                             #
# Copyright (C) 2020 IPFire Development Team <info@ipfire.org>                #
#                                                                             #
# This library is free software; you can redistribute it and/or               #
# modify it under the terms of the GNU Lesser General Public                  #
# License as published by the Free Software Foundation; either                #
# version 2.1 of the License, or (at your option) any later version.          #
#                                                                             #
# This library is distributed in the hope that it will be useful,             #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           #
# Lesser General Public License for more details.                             #
#                                                                             #
###############################################################################

import argparse
import ipaddress
import logging
import math
import re
import sys

# Load our location module
import location
import location.database
import location.importer
from location.i18n import _

# Initialise logging
log = logging.getLogger("location.importer")
log.propagate = 1

INVALID_ADDRESSES = (
	"0.0.0.0",
	"::/0",
	"0::/0",
)

class CLI(object):
	def parse_cli(self):
		parser = argparse.ArgumentParser(
			description=_("Location Importer Command Line Interface"),
		)
		subparsers = parser.add_subparsers()

		# Global configuration flags
		parser.add_argument("--debug", action="store_true",
			help=_("Enable debug output"))

		# version
		parser.add_argument("--version", action="version",
			version="%(prog)s @VERSION@")

		# Database
		parser.add_argument("--database-host", required=True,
			help=_("Database Hostname"), metavar=_("HOST"))
		parser.add_argument("--database-name", required=True,
			help=_("Database Name"), metavar=_("NAME"))
		parser.add_argument("--database-username", required=True,
			help=_("Database Username"), metavar=_("USERNAME"))
		parser.add_argument("--database-password", required=True,
			help=_("Database Password"), metavar=_("PASSWORD"))

		# Update WHOIS
		update_whois = subparsers.add_parser("update-whois", help=_("Update WHOIS Information"))
		update_whois.set_defaults(func=self.handle_update_whois)

		args = parser.parse_args()

		# Enable debug logging
		if args.debug:
			log.setLevel(logging.DEBUG)

		# Print usage if no action was given
		if not "func" in args:
			parser.print_usage()
			sys.exit(2)

		return args

	def run(self):
		# Parse command line arguments
		args = self.parse_cli()

		# Initialise database
		self.db = self._setup_database(args)

		# Call function
		ret = args.func(args)

		# Return with exit code
		if ret:
			sys.exit(ret)

		# Otherwise just exit
		sys.exit(0)

	def _setup_database(self, ns):
		"""
			Initialise the database
		"""
		# Connect to database
		db = location.database.Connection(
			host=ns.database_host, database=ns.database_name,
			user=ns.database_username, password=ns.database_password,
		)

		with db.transaction():
			db.execute("""
				-- autnums
				CREATE TABLE IF NOT EXISTS autnums(number integer, name text, organization text);
				CREATE UNIQUE INDEX IF NOT EXISTS autnums_number ON autnums(number);

				-- inetnums
				CREATE TABLE IF NOT EXISTS inetnums(network inet, name text, country text, description text);
				CREATE UNIQUE INDEX IF NOT EXISTS inetnums_networks ON inetnums(network);
				CREATE INDEX IF NOT EXISTS inetnums_family ON inetnums(family(network));

				-- organizations
				CREATE TABLE IF NOT EXISTS organizations(handle text, name text, country text);
				CREATE UNIQUE INDEX IF NOT EXISTS organizations_handle ON organizations(handle);

				-- routes
				CREATE TABLE IF NOT EXISTS routes(network inet, asn integer);
				CREATE UNIQUE INDEX IF NOT EXISTS routes_network ON routes(network);
				CREATE INDEX IF NOT EXISTS routes_family ON routes(family(network));
			""")

		return db

	def handle_update_whois(self, ns):
		downloader = location.importer.Downloader()

		# Download all sources
		for source in location.importer.WHOIS_SOURCES:
			with self.db.transaction():
				with downloader.request(source, return_blocks=True) as f:
					for block in f:
						self._parse_block(block)

	def _parse_block(self, block):
		# Get first line to find out what type of block this is
		line = block[0]

		# inetnum
		if line.startswith("inet6num:") or line.startswith("inetnum:"):
			return self._parse_inetnum_block(block)

		# route
		elif line.startswith("route6:") or line.startswith("route:"):
			return self._parse_route_block(block)

		# aut-num
		elif line.startswith("aut-num:"):
			return self._parse_autnum_block(block)

		# organisation
		elif line.startswith("organisation:"):
			return self._parse_org_block(block)

		# person (ignored)
		elif line.startswith("person:"):
			return

		# domain (ignored)
		elif line.startswith("domain:"):
			return

		# mntner (ignored)
		elif line.startswith("mntner:"):
			return

		# as-block (ignored)
		elif line.startswith("as-block:"):
			return

		# as-set (ignored)
		elif line.startswith("as-set:"):
			return

		# route-set (ignored)
		elif line.startswith("route-set:"):
			return

		# role (ignored)
		elif line.startswith("role:"):
			return

		# key-cert (ignored)
		elif line.startswith("key-cert:"):
			return

		# irt (ignored)
		elif line.startswith("irt:"):
			return

		# Log any unknown blocks
		else:
			log.warning("Unknown block:")
			for line in block:
				log.warning(line)

	def _parse_autnum_block(self, block):
		log.debug("Parsing autnum block:")

		autnum = {}
		for line in block:
			# Split line
			key, val = split_line(line)

			if key == "aut-num":
				m = re.match(r"^(AS|as)(\d+)", val)
				if m:
					autnum["asn"] = m.group(2)

			elif key in ("as-name", "org"):
				autnum[key] = val

		# Skip empty objects
		if not autnum:
			return

		# Insert into database
		self.db.execute("INSERT INTO autnums(number, name, organization) \
			VALUES(%s, %s, %s) ON CONFLICT (number) DO UPDATE SET \
				name = excluded.name, organization = excluded.organization",
			autnum.get("asn"), autnum.get("as-name"), autnum.get("org"),
		)

	def _parse_inetnum_block(self, block):
		inetnum = {}
		for line in block:
			# Split line
			key, val = split_line(line)

			if key == "inetnum":
				start_address, delim, end_address = val.partition("-")

				# Strip any excess space
				start_address, end_address = start_address.rstrip(), end_address.strip()

				# Skip invalid blocks
				if start_address in INVALID_ADDRESSES:
					return

				# Convert to IP address
				try:
					start_address = ipaddress.ip_address(start_address)
					end_address   = ipaddress.ip_address(end_address)
				except ValueError:
					log.warning("Could not parse line: %s" % line)
					return

				# Set prefix to default
				prefix = 32

				# Count number of addresses in this subnet
				num_addresses = int(end_address) - int(start_address)
				if num_addresses:
					prefix -= math.log(num_addresses, 2)

				inetnum["inetnum"] = "%s/%.0f" % (start_address, prefix)

			elif key == "inet6num":
				# Skip invalid blocks
				if val in INVALID_ADDRESSES:
					return

				inetnum[key] = val

			elif key == "netname":
				inetnum[key] = val

			elif key == "country":
				if val == "UNITED STATES":
					val = "US"

				inetnum[key] = val.upper()

			elif key == "descr":
				if key in inetnum:
					inetnum[key] += "\n%s" % val
				else:
					inetnum[key] = val

		# Skip empty objects
		if not inetnum:
			return

		network = ipaddress.ip_network(inetnum.get("inet6num") or inetnum.get("inetnum"), strict=False)

		self.db.execute("INSERT INTO inetnums(network, name, country, description) \
			VALUES(%s, %s, %s, %s) ON CONFLICT (network) DO \
			UPDATE SET name = excluded.name, country = excluded.country, description = excluded.description",
			"%s" % network, inetnum.get("netname"), inetnum.get("country"), inetnum.get("descr"),
		)

	def _parse_org_block(self, block):
		org = {}
		for line in block:
			# Split line
			key, val = split_line(line)

			if key in ("organisation", "org-name", "country"):
				org[key] = val

		# Skip empty objects
		if not org:
			return

		self.db.execute("INSERT INTO organizations(handle, name, country) \
			VALUES(%s, %s, %s) ON CONFLICT (handle) DO \
			UPDATE SET name = excluded.name, country = excluded.country",
			org.get("organisation"), org.get("org-name"), org.get("country"),
		)

	def _parse_route_block(self, block):
		route = {}
		for line in block:
			# Split line
			key, val = split_line(line)

			# Keep any significant data
			if key in ("route6", "route"):
				route[key] = val

			elif key == "origin":
				m = re.match(r"^(AS|as)(\d+)", val)
				if m:
					route["asn"] = m.group(2)

		# Skip empty objects
		if not route:
			return

		network = ipaddress.ip_network(route.get("route6") or route.get("route"), strict=False)

		self.db.execute("INSERT INTO routes(network, asn) \
			VALUES(%s, %s) ON CONFLICT (network) DO UPDATE SET asn = excluded.asn",
			"%s" % network, route.get("asn"),
		)


def split_line(line):
	key, colon, val = line.partition(":")

	# Strip any excess space
	key = key.strip()
	val = val.strip()

	return key, val

def main():
	# Run the command line interface
	c = CLI()
	c.run()

main()
